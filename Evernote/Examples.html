<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Linux version 5.2.0">
  <title>Examples</title>
</head>
<body>
  <basefont face="Segoe UI" size="2"></basefont>
  <meta http-equiv="Content-Type" content=
  "text/html;charset=utf-8">
  <meta name="exporter-version" content=
  "Evernote Windows/308094 (en-US, DDL); Windows/10.0.0 (Win64);">
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style><a name="1501" id="1501"></a>
  <h1>Examples</h1>
  <div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Tokens:<br>
      <br>
      1. Keywork(small string)<br>
      2. Identifier (Capital string)<br>
      3. Symbol<br>
      4. String<br>
      5. Number<br>
      6. White<br>
      7. NL<br>
      8. Work</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      TODO: Area to work on is Type definations</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Note:<br>
      1. Whenver you have { }, all CNL or NL inside convert
      themselve to white untill NL only line happens<br>
      2. A line will have comments at the end chopped off<br>
      3. The ; is for joining lines, similar to Python's \<br>
      <br>
      Descrition:<br>
      Starting from module, There are definations for variables,
      functions (using defines), classes, and<br>
      rules (headed or not), predicate.<br>
      <br>
      <br>
      Syntax Examples:<br>
      <br>
      -- This is comment amd the other comment is {- -}, the inline
      one<br>
      <br>
      -- First the variable starting Car with an optional type.<br>
      <br>
      Const int D = 34<br>
      <br>
      -- You can even define lamda functions like that<br>
      <br>
      Const D = lamda (A,S,V,F) =&gt; A + S<br>
      <br>
      -- or even:<br>
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Const D = lamda (A,S,V,F) =&gt; A + S :</span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      E=T</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      F=T.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      -- the scope block opertor : should be lowers priority<br>
      <br>
      {-</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      NOO : Once it counters { and }, all nos inside convert into
      space</span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br>
      -}<br>
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      -- This is multi line list, terminated by a . and nl</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Const D :=</span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      [<br>
      ty,<br>
      ty,<br>
      ty<br>
      ty<br>
      ].<br>
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      -- This is again a multi line term, terminated by a . &
      nl</span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Const E :=<br>
      term("fghh",<br>
      [<br>
      ty,<br>
      ty,<br>
      ty,<br>
      ty<br>
      ]<br>
      ).<br>
      <br>
      -- Then comes function inside class: Function [optnal type]
      Name(Params) = expr, and you can have scope block thing here
      :</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Type Name&lt;type,type&gt; = struct(X,Y,Z): interface1,
      interface 2</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      var XX = Xexpr ; is line continuation</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      var YY = Yexpr</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      assert S1 :</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      b</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      c.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      assert S2:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      b</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      c.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Function A(r,t,y,) = R(t,y,c):</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      f</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      g</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      h.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Static Function type Return(T,Y,U) = R:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      R = T.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Type Name&lt;Type, Type&gt; = union:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Line A(A, B, R),</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Line B(A, B, R).</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Interface name:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Function int Name(int, int, int) - - you cannot have</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Function string Name2(string, _). - - skip types by _ and
      skip return types also</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Feature Name:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      out The(T, R, E) = Something:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      blah blah</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      blah blah.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      out The(T, R, E):</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      blah blah.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      rule:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      g</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      assert message ?- expr:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a1</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a2</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a3.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      b.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      rule F(r,t,):</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      b</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      c.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      in Del(A, B, C)</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      const D = 451</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      assert Message_Expr:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      b</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      c.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      assert Message_Expr:</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      a</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      b</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      c.</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Function Nikhil(int R, int S) = T:</span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      T = R + S</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      Assert condition -&gt; message (can have scopt here).</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br>
      {- Here, the form is expr: nl [ multiple assignments adn then
      nl and ] nl</span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      The : operator has the least pririty for this reason. You can
      raise exceptions -}</span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br>
      -- Type name = collecntions of unions<br>
      Type line = line1(int) ; line2(int, int)<br>
      <br>
      -- You could also have the same := where it will look for a .
      to end<br>
      <br>
      Type line :=<br>
      line1(int);<br>
      line2(int, int).<br>
      <br>
      -- Types can be unions or parametric classes, which needs to
      written as -&gt;<br>
      Type myMap -&gt; map(int, int)<br>
      <br>
      -- Note that type should always be lower cased<br>
      <br>
      -- Now the class defination<br>
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br>
      -- If the name starts with _, then it is private<br>
      <br>
      <br></span>
    </div>
    <div>
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br></span>
    </div>
    <div align="left">
      <span style=
      "word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
      <br>
      <br>
      % TO DO: adding String format to expr<br>
      <br>
      % 1. Complete Definations (with exceptions)<br>
      % 2. Design Transformer(Old Program-&gt;New Program,
      ErrorList)<br>
      % 3. Executionaer<br>
      % 4. Builder<br>
      % 5. Main<br>
      % 6.<br>
      <br>
      <br>
      <br>
      Function T(T,Y,U,U) = R:<br>
      [<br>
      <br>
      <br>
      ]<br>
      <br>
      For Function statements::- type expr ---&gt;<br>
      exprIf(pos(expr), pos(expr), pos(expr)); % exprIf(Condition,
      Then, Else)<br>
      exprData(data); % Data<br>
      exprVar(identifier); % Variable<br>
      exprCall(identifier, block(expr)); % Func/ Pred call with all
      vars bound<br>
      exprOp1(operator1, pos(expr));<br>
      exprOp2(operator2, pos(expr), pos(expr));<br>
      exprTerm(pos(string), block(expr)); % Term expression<br>
      exprLet(list(pair), pos(expr));<br>
      exprSeq(block(statement(pred)), pos(expr));<br>
      exprEval(block(expr), pos(expr)); same as call<br>
      exprSwitch(pos(expr), block(switchCaseExpr), pos(expr)). %
      Expr, Case list, Default Case<br>
      <br>
      But for Expr: onlt "if then" and "let in", so no switch and
      sequence<br>
      <br>
      For Predicate statement:<br>
      <br>
      statementAssert(pos(expr));<br>
      statementStop;<br>
      statementContinue;<br>
      statementUnify(pos(pattern), pos(pattern));<br>
      statementIf(pos(expr), block(statement(T)));<br>
      statementIfElse(pos(expr), block(statement(T)),
      block(statement(T)));<br>
      statementCall(pos(string), block(pattern));<br>
      statementSwitch(pos(pattern), block(switchCase(T)),
      block(statement(T)));% Expr, Case list, Default Case<br>
      statementMember(pos(pattern), pos(pattern));<br>
      statementCustom(T).<br>
      <br>
      :=<br>
      [<br>
      <br>
      ]<br>
      <br>
      :- module definations.<br>
      <br>
      :- interface.<br>
      <br>
      :- import_module io, int, list, string, bool, char.<br>
      <br>
      :- pred main(io::di, io::uo) is det.<br>
      <br>
      :- type counter == int. % Unsigned Number<br>
      <br>
      :- type number == int. % Signed Number<br>
      <br>
      :- type position == { string, counter, counter }. %
      (filename, linepos, counter)<br>
      <br>
      :- type pos(T) ---&gt; position(val::T, position).<br>
      <br>
      :- type block(T) == list(pos(T)).<br>
      <br>
      :- type operator1 ---&gt; opNegate ; opNot.<br>
      <br>
      :- type operator2 ---&gt; opAdd ; opSub ; opMult ; opDiv ;
      opAppend ; opNeq ; opGt ;<br>
      opGe ; opLt ; opLe ; opAnd ; opOr ; opEq ; opIn.<br>
      <br>
      %:- type identifier ---&gt; this(pos(string)) ;
      that(pos(string), pos(string)).<br>
      :- type identifier == pos(string).<br>
      <br>
      :- type data.<br>
      :- type expr.<br>
      :- type pattern.<br>
      :- type pair.<br>
      :- type predType.<br>
      :- type ruleType.<br>
      :- type statement(_).<br>
      :- type typeDef.<br>
      <br>
      :- type data ---&gt;<br>
      dataChar(char);<br>
      dataNum(number);<br>
      dataBool(bool);<br>
      dataFunction(list(string), expr);<br>
      dataOperator1(operator1);<br>
      dataOperator2(operator2);<br>
      dataTuple(list(data));<br>
      dataTerm(string, list(data)).<br>
      <br>
      :- type expr ---&gt;<br>
      exprIf(pos(expr), pos(expr), pos(expr)); % exprIf(Condition,
      Then, Else)<br>
      exprData(data); % Data<br>
      exprVar(identifier); % Variable<br>
      exprCall(identifier, block(expr)); % Func/ Pred call with all
      vars bound<br>
      exprOp1(operator1, pos(expr));<br>
      exprOp2(operator2, pos(expr), pos(expr));<br>
      exprTerm(pos(string), block(expr)); % Term expression<br>
      exprLet(list(pair), pos(expr));<br>
      exprSeq(block(statement(pred)), pos(expr));<br>
      exprEval(block(expr), pos(expr));<br>
      exprSwitch(pos(expr), block(switchCaseExpr), pos(expr)). %
      Expr, Case list, Default Case<br>
      <br>
      :- type pair == { pos(string), pos(expr) }.<br>
      <br>
      :- type switchCaseExpr == { pattern, pos(expr), pos(expr)
      }.<br>
      <br>
      :- type pattern ---&gt;<br>
      patternExpr(pos(expr));<br>
      patternIgnore(position);<br>
      patternUnify(pos(string));<br>
      patternTerm(pos(string), block(pattern)).<br>
      <br>
      :- type statement(T) ---&gt;<br>
      statementAssert(pos(expr));<br>
      statementStop;<br>
      statementContinue;<br>
      statementUnify(pos(pattern), pos(pattern));<br>
      statementIf(pos(expr), block(statement(T)));<br>
      statementIfElse(pos(expr), block(statement(T)),
      block(statement(T)));<br>
      statementCall(pos(string), block(pattern));<br>
      statementSwitch(pos(pattern), block(switchCase(T)),
      block(statement(T)));% Expr, Case list, Default Case<br>
      statementMember(pos(pattern), pos(pattern));<br>
      statementCustom(T).<br>
      <br>
      :- type switchCase(T) == { pattern, pos(expr),
      block(statement(T)) }.<br>
      <br>
      :- type predType ---&gt;
      predStatementOr(list(block(statement(predType)))).<br>
      <br>
      :- type ruleType ---&gt;<br>
      ruleStatementAnd(list(block(statement(predType))));<br>
      ruleStatementExport(identifier, block(string));<br>
      ruleStatementDesignError(pos(expr));<br>
      ruleStatementFileGenerate(pos(expr), pos(expr)).<br>
      <br>
      :- type param ---&gt;<br>
      paramTyped(pos(typeDef), pos(string));<br>
      paramUntyped(pos(string)).<br>
      <br>
      :- type coreDef ---&gt;<br>
      defFunc(pos(string), block(param), pos(expr));<br>
      defPred(pos(string), block(param),
      block(statement(predType)));<br>
      defConst(pos(param), pos(data)).<br>
      <br>
      :- type typeDef ---&gt;<br>
      typeTuple(block(typeDef));<br>
      typeCustom(pos(string), block(typeDef)).<br>
      <br>
      :- type entity ---&gt;<br>
      entityRule(block(statement(ruleType)));<br>
      entityNamedRule(pos(string), block(param),
      block(statement(ruleType)));<br>
      entityRuleHead(pos(string), block(typeDef)); % Block of
      Params without names<br>
      entityCore(coreDef).<br>
      <br>
      %:- type moduleDef == { pos(string), block(parse) }.<br>
      <br>
      :- type program == list(moduleDef)<br>
      <br>
      <br>
      %:- type defKey == { string, int }.<br>
      <br>
      :- implementation.<br>
      <br>
      main(!IO) :- io.write_string("Hello, ", !IO), io.nl(!IO).<br>
      <br>
      % :- type calc_info == map(string, int).<br>
      <br>
      <br>
      % type Transform = (Identifier list) * (Pred Statement
      block)<br>
      <br>
      % type Transforms = Transform list<br>
      <br>
      % type ProgramError = Position * pExpr * (Pred Statement
      block)<br>
      <br>
      % type ProgramFile = Position * pExpr * pExpr * (Pred
      Statement block)<br>
      <br>
      % type ProgramMap = Map&lt;(string*int), Transforms
      Def&gt;<br>
      <br>
      % type Program = ProgramMap * (ProgramError list) *
      (ProgramFile list)<br>
      <br>
      % type TokenGroup = TokenGroup1 | TokenGroup2 |
      TokenGroup3<br>
      <br>
      :-type Element<br>
      % | ElementList of TokenGroup * Elements<br>
      % | ElementIdentifier0 of string<br>
      % | ElementIdentifier1 of string<br>
      % | ElementString of string<br>
      % | ElementAnonymous<br>
      % | ElementUnify of string<br>
      % | ElementNumber of integer<br>
      % | ElementSymbols of string<br>
      <br>
      % and Elements = (Position * Element) list<br>
      <br>
      % type State = Map&lt;string, Data&gt;<br>
      <br>
      % type States = State list option<br>
      <br>
      % type sourceName = string list<br>
      % type sourceContent = string list<br>
      % type source = sourceName * sourceContent<br>
      % type build = source list<br></span>
    </div>
  </div>
</body>
</html>
